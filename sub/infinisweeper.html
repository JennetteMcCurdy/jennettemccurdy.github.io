<!DOCTYPE html>

<body>

    <head>
        <title>Infinisweeper</title>
        <link href="new_minesweeper.css" rel="stylesheet">
        <link rel="icon" type="image/png" href="https://www.kircic.org/sub/minesweeper_assets/mine_red.png">
        <meta charset="UTF-8">
        <meta name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Infinisweeper">
        <meta property="og:description" content="An infinite minesweeper sandbox.">
        <meta property="og:image" content="https://www.kircic.org/sub/minesweeper_assets/mine_red.png" />
        <meta property="og:url" content="https://www.kircic.org/sub/infinisweeper.html">
        <meta name="description" content="An infinite minesweeper sandbox.">
        <meta name="keywords" content="minesweeper, infinite, infinisweeper">
        <meta name="author" content="kircic.org">
        <meta name="robots" content="index, follow">
    </head>

    <body>
        <div id="game_holder">
            <div id="game" style="left: 0px; top: 0px">
                <div id="ghost_tile" style="left: 999%; top: 999%"></div>
            </div>
        </div>

        <div id="info_overlay">
            <div class="left_data_list">
                <span class="bold">Infinisweeper v1.2.3</span>
                <span class="point_count">Points: 0</span>
                <br>
                <span class="tile_count">Tiles Discovered: 0</span>
                <span class="bomb_count">Bombs: 0</span>
                <span class="flag_count">Flags: 0</span>
                <br>
                <span class="chunk_id">Chunk ID: [0, 0]</span>
                <span class="tile_id">Tile ID: [0, 0]</span>
                <br>
                <div>
                    <span class="chunk_bounds">Display Chunk Bounds:</span>
                    <input type="checkbox" class="chunk_bounds_check">
                </div>
                <br>
                <div>
                    <span class="invert">Invert Colors:</span>
                    <input type="checkbox" class="invert_colors_check">
                </div>
            </div>

            <div class="right_data_list">
                <span class="autosave_text">Autosaving...</span>
            </div>
        </div>

        <div id="button_holder">
            <div class='left_button'>
                <button class="flagging" title="Flagging Mode"></button>
                <button class="movement" title="Drag Lock">
                    <div class="icon"></div>
                </button>
                <button class="center" title="Center">
                    <div class="icon"></div>
                </button>   
                <button class="reset" title="Reset">
                    <div class="icon"></div>
                </button>
                <button class="settings" title="Settings">
                    <div class="icon"></div>
                </button>
            </div>

            <div class="right_button">
                <button class="import" title="Import">
                    <div class="icon"></div>
                </button>
                <button class="export" title="Export">
                    <div class="icon"></div>
                </button> 
            </div>
        </div>

        <canvas id="placeholder" width="512" height="512"></canvas>

        <script>
            const game_holder = document.querySelector('#game_holder');
            const game = document.querySelector('#game');
            const placeholder = document.querySelector('#placeholder');
            const ghost_tile = document.querySelector('#ghost_tile');

            const flag_button = document.querySelector('button.flagging');
            const move_button = document.querySelector('button.movement');
            const center_button = document.querySelector('button.center');
            const import_button = document.querySelector('button.import');
            const export_button = document.querySelector('button.export');
            const reset_button = document.querySelector('button.reset');

            const autosave_text = document.querySelector('.autosave_text');
            const tile_count = document.querySelector('.tile_count');
            const flag_count = document.querySelector('.flag_count');
            const bomb_count = document.querySelector('.bomb_count');
            const point_count = document.querySelector('.point_count');
            const chunk_id = document.querySelector('.chunk_id');
            const tile_id = document.querySelector('.tile_id');

            const chunk_bounds_check = document.querySelector('.chunk_bounds_check');
            const invert_colors_check = document.querySelector('.invert_colors_check');

            const searchArray = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ]
            const numberToImage = {
                0: 'minesweeper_assets/0.png',
                1: 'minesweeper_assets/1.png',
                2: 'minesweeper_assets/2.png',
                3: 'minesweeper_assets/3.png',
                4: 'minesweeper_assets/4.png',
                5: 'minesweeper_assets/5.png',
                6: 'minesweeper_assets/6.png',
                7: 'minesweeper_assets/7.png',
                8: 'minesweeper_assets/8.png',
                'bomb': 'minesweeper_assets/mine_red.png',
                'flag': 'minesweeper_assets/flag.png',
                'outset': 'minesweeper_assets/outset.png'
            }

            let currentKeysDown = [];
            let bombLocations = {};
            let flagLocations = {};
            let foundLocations = {};
            let numberDatabase = {};

            let gameStats = {
                tileCount: 0,
                flagCount: 0,
                bombCount: 0,
                pointCount: 0,
            }

            var isMouseDown = false;
            var dragging = false;
            var dragLock = false;
            var flagging = false;
            var currentCanvas;

            function arrayToString(array) {
                return array.x + ':' + array.y
            }

            function stringToArray(string) {
                var splitString = string.split(':');

                return {
                    x: parseInt(splitString[0]),
                    y: parseInt(splitString[1])
                }
            }

            function assignCanvasFunctions(canvasClone) {
                canvasClone.addEventListener('mouseenter', function () {
                    currentCanvas = canvasClone;
                });

                canvasClone.addEventListener('mouseleave', function () {
                    currentCanvas = null;
                });

                canvasClone.addEventListener('mousedown', function (event) {
                    makeTile(canvasClone, event);
                });
            }

            function getTileNumber(canvasClone, tilePosition, normalTilePosition) {
                var canvasPosition = {
                    x: parseInt(canvasClone.getAttribute('x')),
                    y: parseInt(canvasClone.getAttribute('y'))
                }

                var newTilePosition;
                if (!normalTilePosition) {
                    newTilePosition = {
                        x: Math.ceil(tilePosition.x / 512 * 20),
                        y: Math.ceil(tilePosition.y / 512 * 20)
                    }
                } else {
                    newTilePosition = normalTilePosition;
                }

                var canvasPositionString = arrayToString(canvasPosition);
                var newTilePositionString = arrayToString(newTilePosition);
                var thisBombArray = bombLocations[canvasPositionString];

                if (!thisBombArray.includes(newTilePositionString)) {
                    var bombCount = 0;
                    for (var i = 0; i < searchArray.length; i++) {
                        var thisOffset = searchArray[i];
                        var searchTilePosition = {
                            x: newTilePosition.x + thisOffset.x,
                            y: newTilePosition.y + thisOffset.y
                        };

                        var canvasPositionOffset = {
                            x: 0,
                            y: 0
                        }

                        if (searchTilePosition.x > 19) {
                            searchTilePosition.x = 0;
                            canvasPositionOffset.x = 1;
                        } else if (searchTilePosition.x < 0) {
                            searchTilePosition.x = 19;
                            canvasPositionOffset.x = -1;
                        }

                        if (searchTilePosition.y > 19) {
                            searchTilePosition.y = 0;
                            canvasPositionOffset.y = 1;
                        } else if (searchTilePosition.y < 0) {
                            searchTilePosition.y = 19;
                            canvasPositionOffset.y = -1;
                        }

                        var newCanvasArray = {
                            x: canvasPosition.x + canvasPositionOffset.x,
                            y: canvasPosition.y + canvasPositionOffset.y
                        }
                        var newCanvasString = arrayToString(newCanvasArray);
                        if (!bombLocations[newCanvasString]) {
                            generateCanvas(newCanvasArray);
                        }

                        var newBombArray = bombLocations[newCanvasString];
                        var searchTileString = arrayToString(searchTilePosition);
                        if (newBombArray.includes(searchTileString)) {
                            bombCount++;
                        }
                    }
                    return bombCount;
                } else {
                    return 'bomb';
                }
            }

            function makeTile(canvasClone, event, convertedPos, bypass, flag) {
                const classBlacklist = ['input', 'button']
                if (event && event.target && classBlacklist.includes(event.target.tagName.toLowerCase())) { return }
                if (!flag && event && (event.which != 1)) { return }

                if (!dragging && !dragLock) {
                    var ctx = canvasClone.getContext('2d');
                    var tileWidth = (1 / 20) * 512;
                    var canvasRect = canvasClone.getBoundingClientRect();
                    var offsetMouse;

                    if (event) {
                        offsetMouse = {
                            x: Math.floor(Math.floor((event.x - canvasRect.x) / tileWidth) * tileWidth),
                            y: Math.floor(Math.floor((event.y - canvasRect.y) / tileWidth) * tileWidth)
                        }
                    } else {
                        offsetMouse = convertedPos;
                    }

                    var nonConverted = {
                        x: Math.ceil(offsetMouse.x / tileWidth),
                        y: Math.ceil(offsetMouse.y / tileWidth)
                    }

                    var canvasPosition = {
                        x: parseInt(canvasClone.getAttribute('x')),
                        y: parseInt(canvasClone.getAttribute('y'))
                    }
                    var canvasString = arrayToString(canvasPosition);
                    var offsetMouseString = arrayToString(offsetMouse);
                    var nonConvertedString = arrayToString(nonConverted);
                    var madeFlag = false;

                    function applyTileBackground() {
                        // tile background (border)
                        ctx.fillStyle = '#545454';
                        ctx.fillRect(offsetMouse.x, offsetMouse.y, tileWidth, tileWidth);

                        // tile background
                        ctx.fillStyle = '#6e6e6e';
                        ctx.fillRect(offsetMouse.x + 1, offsetMouse.y + 1, tileWidth - 2, tileWidth - 2);
                    }

                    function makeFlag() {
                        if (!flagLocations[canvasString].includes(nonConvertedString)) {
                            if (!foundLocations[canvasString].includes(nonConvertedString)) {
                                flagLocations[canvasString].push(nonConvertedString);

                                applyTileBackground();

                                var flagImage = new Image();
                                flagImage.src = numberToImage['flag'];

                                flagImage.onload = function () {
                                    ctx.drawImage(flagImage, offsetMouse.x, offsetMouse.y, tileWidth, tileWidth);
                                }
                                gameStats.flagCount++;
                            }
                        } else {
                            removeFlag();
                        }
                    }

                    function removeFlag() {
                        var flagIndex = flagLocations[canvasString].indexOf(nonConvertedString);
                        flagLocations[canvasString].splice(flagIndex, 1);
                        gameStats.flagCount--;

                        ctx.clearRect(offsetMouse.x, offsetMouse.y, tileWidth, tileWidth)
                    }

                    function makeNumber() {
                        if (flagLocations[canvasString].includes(nonConvertedString)) {
                            removeFlag();
                        } else {
                            foundLocations[canvasString].push(nonConvertedString);
                            applyTileBackground();

                            // tile image
                            var tileNumber = getTileNumber(canvasClone, offsetMouse);
                            numberDatabase[canvasString][nonConvertedString] = tileNumber;

                            if (tileNumber == 'bomb') {
                                gameStats.bombCount++;
                            }

                            var tileImage = new Image();

                            if (bypass || (event && tileNumber == 0)) {
                                startSearch(canvasClone, offsetMouse, event);
                            }

                            tileImage.src = numberToImage[tileNumber];

                            tileImage.onload = function () {
                                ctx.drawImage(tileImage, offsetMouse.x, offsetMouse.y, tileWidth, tileWidth);
                            }

                            gameStats.tileCount++;
                        }
                    }

                    if (event) {
                        if (foundLocations[canvasString].includes(nonConvertedString)) {
                            runFlagCheck(currentCanvas, nonConverted);
                        } else if (flagging) {
                            makeFlag();
                            madeFlag = true;
                        }
                    }

                    if (flag) {
                        makeFlag();
                        madeFlag = true;
                    }

                    if (!flag && !madeFlag && !foundLocations[canvasString].includes(nonConvertedString)) {
                        makeNumber();
                    }

                    updateStats();
                }
            }

            function updateStats() {
                calculatePoints();

                tile_count.innerHTML = 'Tiles Discovered: ' + gameStats.tileCount;
                flag_count.innerHTML = 'Flags: ' + gameStats.flagCount;
                bomb_count.innerHTML = 'Bombs: ' + gameStats.bombCount;
                point_count.innerHTML = 'Points: ' + gameStats.pointCount;
            }

            function calculatePoints() {
                gameStats.pointCount = (gameStats.tileCount * 2) + (gameStats.bombCount * -20);
            }

            function runFlagCheck(canvasClone, tilePosition) {
                var canvasPosition = {
                    x: parseInt(canvasClone.getAttribute('x')),
                    y: parseInt(canvasClone.getAttribute('y'))
                }
                var canvasString = arrayToString(canvasPosition);
                var tilePositionString = arrayToString(tilePosition);

                var tileNumber = numberDatabase[canvasString][tilePositionString];
                var foundFlags = 0;

                let surroundingTiles = [];

                for (var i = 0; i < searchArray.length; i++) {
                    var thisOffset = searchArray[i];
                    var checkPosition = {
                        x: tilePosition.x + thisOffset.x,
                        y: tilePosition.y + thisOffset.y
                    }

                    var canvasOffset = {
                        x: 0,
                        y: 0
                    }

                    if (checkPosition.x >= 20) {
                        checkPosition.x = 0;
                        canvasOffset.x = 1
                    } else if (checkPosition.x < 0) {
                        checkPosition.x = 19;
                        canvasOffset.x = -1
                    }

                    if (checkPosition.y >= 20) {
                        checkPosition.y = 0;
                        canvasOffset.y = 1;
                    } else if (checkPosition.y < 0) {
                        checkPosition.y = 19;
                        canvasOffset.y = -1;
                    }

                    var newCanvasPosition = {
                        x: canvasPosition.x + canvasOffset.x,
                        y: canvasPosition.y + canvasOffset.y
                    }
                    var newCanvasString = arrayToString(newCanvasPosition);
                    var newTileString = arrayToString(checkPosition);


                    if (!flagLocations[newCanvasString]) {
                        flagLocations[newCanvasString] = [];
                    }
                    if (flagLocations[newCanvasString].includes(newTileString)) {
                        foundFlags++;
                    } else {
                        surroundingTiles.push({ canvas: newCanvasString, tilePos: newTileString });
                    }
                }

                if (foundFlags == tileNumber) {
                    for (var i = 0; i < surroundingTiles.length; i++) {
                        var thisTileData = surroundingTiles[i];
                        var thisCanvasArray = stringToArray(thisTileData.canvas);
                        var thisPositionArray = stringToArray(thisTileData.tilePos);
                        var thisCanvasElement = document.querySelector(`canvas[x="${thisCanvasArray.x}"][y="${thisCanvasArray.y}"]`);

                        var thisConvertedPos = {
                            x: thisPositionArray.x / 20 * 512,
                            y: thisPositionArray.y / 20 * 512
                        }

                        makeTile(thisCanvasElement, null, thisConvertedPos, true);
                    }
                }
            }

            function startSearch(canvasClone, tilePosition) {
                var canvasPosition = {
                    x: parseInt(canvasClone.getAttribute('x')),
                    y: parseInt(canvasClone.getAttribute('y'))
                };
                var thisCanvasString = arrayToString(canvasPosition);

                var newTilePosition = {
                    x: Math.ceil(tilePosition.x / 512 * 20),
                    y: Math.ceil(tilePosition.y / 512 * 20)
                };

                var checked = {};
                var zeros = [];
                var borderingSquares = []; // Array to store bordering squares

                findConnectedZeros(newTilePosition);

                function findConnectedZeros(tilePosition) {
                    var key = `${tilePosition.x},${tilePosition.y}`;

                    // Check if the tile is already checked or outside the bounds
                    if (
                        checked[key] ||
                        tilePosition.x < 0 || tilePosition.x >= 20 ||
                        tilePosition.y < 0 || tilePosition.y >= 20
                    ) {
                        var newCanvasOffset = {
                            x: 0,
                            y: 0
                        };

                        var newTilePosition = {
                            x: tilePosition.x / 20 * 512,
                            y: tilePosition.y / 20 * 512
                        }

                        if (tilePosition.x >= 20) {
                            newCanvasOffset.x = 1;
                            newTilePosition.x = 0;
                        } else if (tilePosition.x < 0) {
                            newCanvasOffset.x = -1;
                            newTilePosition.x = 19 / 20 * 512;
                        }

                        if (tilePosition.y >= 20) {
                            newCanvasOffset.y = 1;
                            newTilePosition.y = 0;
                        } else if (tilePosition.y < 0) {
                            newCanvasOffset.y = -1;
                            newTilePosition.y = 19 / 20 * 512;
                        }

                        var newCanvasPosition = {
                            x: canvasPosition.x + newCanvasOffset.x,
                            y: canvasPosition.y + newCanvasOffset.y
                        }

                        var newCanvas = document.querySelector(`canvas[x="${newCanvasPosition.x}"][y="${newCanvasPosition.y}"]`);
                        makeTile(newCanvas, null, newTilePosition, true);

                        return;
                    }

                    checked[key] = true; // Mark the tile as checked

                    var convertedPos = {
                        x: tilePosition.x / 20 * 512,
                        y: tilePosition.y / 20 * 512
                    };

                    var thisTileNumber = getTileNumber(canvasClone, convertedPos);

                    if (thisTileNumber === 0) {
                        zeros.push(tilePosition);

                        makeTile(canvasClone, null, convertedPos); // Fill the tile if it's a zero
                        // Recursively find connected zeros in all directions using searchArray
                        for (var i = 0; i < searchArray.length; i++) {
                            var offset = searchArray[i];
                            findConnectedZeros({ x: tilePosition.x + offset.x, y: tilePosition.y + offset.y });
                        }
                    } else {
                        makeTile(canvasClone, null, convertedPos); // Fill the tile if it's a border corner
                    }
                }
            }

            function generateBombs(positionTable) {
                var positionString = arrayToString(positionTable);

                if (!bombLocations[positionString]) {
                    var thisBombArray = [];

                    for (var i = 0; i < 60; i++) {
                        var randomPos = {
                            x: Math.floor(Math.random() * 20),
                            y: Math.floor(Math.random() * 20)
                        }

                        var bombPositionString = arrayToString(randomPos);
                        if (!thisBombArray.includes(bombPositionString)) {
                            thisBombArray.push(bombPositionString);
                        }
                    }

                    bombLocations[positionString] = thisBombArray;
                }
            }

            function generateCanvas(positionTable) {
                var canvasClone = placeholder.cloneNode(true);
                canvasClone.removeAttribute('id');
                canvasClone.setAttribute('x', positionTable.x);
                canvasClone.setAttribute('y', positionTable.y);
                canvasClone.style.left = positionTable.x * 512 + 'px';
                canvasClone.style.top = positionTable.y * 512 + 'px';

                var canvasString = arrayToString(positionTable);
                if (!foundLocations[canvasString]) {
                    foundLocations[canvasString] = [];
                    flagLocations[canvasString] = [];
                    numberDatabase[canvasString] = [];
                }

                generateBombs(positionTable);
                assignCanvasFunctions(canvasClone);
                game.appendChild(canvasClone);

                return canvasClone;
            };

            var startPosition;
            function handleMouseDrag(event) {
                var gameRect = game.getBoundingClientRect();

                if (!game.classList.contains('tween') && (dragging || dragLock) && isMouseDown) {
                    if (!startPosition) {
                        startPosition = {
                            x: event.x - (parseInt(game.style.left) / 100) * gameRect.width,
                            y: event.y - (parseInt(game.style.top) / 100) * gameRect.width
                        }
                    }

                    var offsetPosition = {
                        x: event.x - startPosition.x,
                        y: event.y - startPosition.y
                    }

                    game.style.left = ((offsetPosition.x / gameRect.width) * 100).toFixed(2) + '%';
                    game.style.top = ((offsetPosition.y / gameRect.width) * 100).toFixed(2) + '%';
                }

                updateDisplayPosition(event);
            }

            function updateDisplayPosition(event) {
                var positionData = findChunkID(event);
                var canvasPos = positionData.canvasPos;
                var tilePos = positionData.tilePos;
                var tileWidth = (1 / 20) * 512;

                chunk_id.innerHTML = `Chunk ID: [${canvasPos.x}, ${canvasPos.y}]`;
                tile_id.innerHTML = `Tile ID: [${tilePos.x}, ${tilePos.y}]`

                ghost_tile.style.left = canvasPos.x * 512 + (tileWidth * tilePos.x) + 'px';
                ghost_tile.style.top = canvasPos.y * 512 + (tileWidth * tilePos.y) + 'px';
            }

            function handleMouseDown(event) {
                if (!currentCanvas && !dragging) {
                    var offsetCanvas = findChunkID(event).canvasPos;
                    var newCanvas = generateCanvas(offsetCanvas);
                    makeTile(newCanvas, event);
                }

                isMouseDown = true;
            }

            function findChunkID(event) {
                var gameRect = game.getBoundingClientRect();
                var tileWidth = (1 / 20) * 512;

                var gameOffsetPixels = {
                    x: event.x - gameRect.left,
                    y: event.y - gameRect.top
                }
                var offsetCanvas = {
                    x: Math.ceil((gameOffsetPixels.x) / 512) - 1,
                    y: Math.ceil((gameOffsetPixels.y) / 512) - 1
                }
                var offsetTile = {
                    x: Math.floor((gameOffsetPixels.x - (offsetCanvas.x * 512)) / tileWidth),
                    y: Math.floor((gameOffsetPixels.y - (offsetCanvas.y * 512)) / tileWidth)
                }

                return { canvasPos: offsetCanvas, tilePos: offsetTile };
            }

            function handleMouseUp(event) {
                isMouseDown = false;
                startPosition = null;
            }

            function handleKeyDown(event) {
                if (!currentKeysDown.includes(event.which)) {
                    currentKeysDown.push(event.which);
                }

                if (event.which == 16) {
                    dragging = true;
                } else if (event.which == 70) {
                    handleFlagMode();
                } else if (event.which == 81) {
                    handleMoveMode();
                }
            }

            function handleKeyUp(event) {
                if (currentKeysDown.includes(event.which)) {
                    var keyIndex = currentKeysDown.indexOf(event.which);
                    currentKeysDown.splice(keyIndex, 1);
                }

                if (event.which == 16) {
                    dragging = false;
                }
            }

            function handleContextMenu(event) {
                event.preventDefault();
                makeTile(currentCanvas, event, null, null, true);
            }

            function handleMoveRender() {
                var moveOffset = {
                    87: {x: 0, y: -1},
                    65: {x: -1, y: 0},
                    83: {x: 0, y: 1},
                    68: {x: 1, y: 0},
                }

                var currentGamePos = {
                    x: parseInt(game.style.left),
                    y: parseInt(game.style.top)
                }

                var posOffset = {
                    x: 0,
                    y: 0
                }

                for (var which in moveOffset) {
                    var thisOffset = moveOffset[which];

                    if (currentKeysDown.includes(parseInt(which))) {     
                        posOffset.x = posOffset.x - thisOffset.x;
                        posOffset.y = posOffset.y - thisOffset.y
                    }
                }

                game.style.left = parseInt(game.style.left) + posOffset.x + '%';
                game.style.top = parseInt(game.style.top) + posOffset.y + '%';
                setTimeout(handleMoveRender, 1000/60);
            }

            function createStartingStreak() {
                var tileWidth = (1/20)*512;
                function tryStreak() {
                    var randomTilePosition = {
                        x: Math.floor(Math.random() * 20),
                        y: Math.floor(Math.random() * 20)
                    }
                    var convertedTilePosition = {
                        x: randomTilePosition.x / 20 * 512,
                        y: randomTilePosition.y / 20 * 512
                    }

                    var zeroCanvas = document.querySelector('canvas[x="0"][y="0"]');
                    var thisTileNumber = getTileNumber(zeroCanvas, null, randomTilePosition);

                    if (thisTileNumber == 0) {
                        makeTile(zeroCanvas, null, convertedTilePosition, true);
                        shiftToPosition(null, {x: (randomTilePosition.x*tileWidth)/512, y: (randomTilePosition.y*tileWidth)/512})
                    } else {
                        tryStreak();
                    }
                }

                tryStreak();
            }

            function handleFlagMode() {
                flagging = !flagging;

                if (flagging) {
                    flag_button.classList.add('active');
                } else {
                    flag_button.classList.remove('active');
                }
            }

            function handleMoveMode() {
                startPosition = null;
                dragLock = !dragLock;

                if (dragLock) {
                    move_button.classList.add('active');
                } else {
                    move_button.classList.remove('active');
                }
            }

            function shiftToPosition(event, Position) {
                game.classList.add('tween');

                if (!Position) {
                    game.style.left = '0%';
                    game.style.top = '0%';
                } else {
                    game.style.left = Position.x + '%';
                    game.style.top = Position.y + '%';
                }

                setTimeout(function () {
                    game.classList.remove('tween');
                }, 1000)
            }

            function handleGameReset(event, fromImport) {
                var choiceResult;
                if (!fromImport) {
                    choiceResult = confirm('Reset game? All data will be lost.', 'Yes')
                }

                if (fromImport || (choiceResult == true)) {
                    currentKeysDown = [];
                    bombLocations = {};
                    flagLocations = {};
                    foundLocations = {};
                    numberDatabase = {};

                    gameStats = {
                        tileCount: 0,
                        flagCount: 0,
                        bombCount: 0,
                        pointCount: 0
                    }

                    currentCanvas = null;

                    var allCanvas = document.querySelectorAll('canvas');
                    for (var i = 0; i < allCanvas.length; i++) {
                        var thisCanvas = allCanvas[i];
                        if (!thisCanvas.id) {
                            thisCanvas.remove();
                        }
                    }

                    localStorage.clear();
                    if (!fromImport) {
                        generateCanvas({ x: 0, y: 0 });
                        createStartingStreak();
                    }
                }
            }

            function handleCanvasClasses(value, className) {
                var allCanvas = document.querySelectorAll('canvas');

                for (var i = 0; i < allCanvas.length; i++) {
                    var thisCanvas = allCanvas[i];

                    if (value) {
                        thisCanvas.classList.add(className);
                    } else {
                        thisCanvas.classList.remove(className);
                    }
                }
            }

            function handleChunkBounds() {
                handleCanvasClasses(chunk_bounds_check.checked, 'borders');
            }

            function handleInvertColors() {
                handleCanvasClasses(invert_colors_check.checked, 'invert');
            }

            function JSONify(table) {
                var jsonData = JSON.stringify(table);
                return jsonData;
            }

            function Tableify(json) {
                var tableData = JSON.parse(json);
                return tableData;
            }

            function convertToNestedObject(obj) {
                const result = {};
                for (const key in obj) {
                    result[key] = {};
                    for (const nestedKey in obj[key]) {
                        result[key][nestedKey] = obj[key][nestedKey];
                    }
                }
                return result;
            }

            function getCurrentPosition() {
                var gamePosition = {
                    x: parseInt(game.style.left),
                    y: parseInt(game.style.top)
                }

                return gamePosition;
            }

            function saveData() {
                var data = {
                    saveFoundLocations: foundLocations,
                    saveBombLocations: bombLocations,
                    saveFlagLocations: flagLocations,
                    saveNumberDatabase: convertToNestedObject(numberDatabase),
                    saveGameStats: gameStats,
                    saveGamePosition: getCurrentPosition()
                }

                var saveText = JSONify(data);
                localStorage.setItem('saveData', saveText);
                return saveText;
            }

            function loadData(imported) {
                var tileWidth = (1 / 20) * 512;
                var data = imported || Tableify(localStorage.getItem('saveData'));
                var saveNumberDatabase = data.saveNumberDatabase;
                var saveFlags = data.saveFlagLocations;

                if (data.saveGamePosition) {
                    game.style.left = data.saveGamePosition.x + '%';
                    game.style.top = data.saveGamePosition.y + '%';
                }

                for (var i in saveNumberDatabase) {
                    var thisCanvasArray = stringToArray(i);
                    var thisCanvas = generateCanvas(thisCanvasArray);
                    var ctx = thisCanvas.getContext('2d');

                    for (var j in saveNumberDatabase[i]) {
                        var thisPositionArray = stringToArray(j);
                        var thisTileNumber = saveNumberDatabase[i][j];

                        ctx.fillStyle = 'gray';
                        ctx.fillRect(
                            thisPositionArray.x * tileWidth,
                            thisPositionArray.y * tileWidth,
                            tileWidth,
                            tileWidth
                        );

                        (function (ctx, thisPositionArray, thisTileNumber) {
                            var newImage = new Image();
                            newImage.src = numberToImage[thisTileNumber];

                            newImage.onload = function () {
                                ctx.drawImage(
                                    newImage,
                                    thisPositionArray.x * tileWidth,
                                    thisPositionArray.y * tileWidth,
                                    tileWidth,
                                    tileWidth
                                );
                            };
                        })(ctx, thisPositionArray, thisTileNumber);
                    }
                }

                for (var i in saveFlags) {
                    var thisChunkData = saveFlags[i];
                    var thisChunkArray = stringToArray(i);
                    var thisCanvas = document.querySelector(`canvas[x="${thisChunkArray.x}"][y="${thisChunkArray.y}"]`);
                    var ctx = thisCanvas.getContext('2d');

                    for (var j = 0; j < thisChunkData.length; j++) {
                        var thisFlagPosition = thisChunkData[j];
                        var thisFlagArray = stringToArray(thisFlagPosition);

                        var convertedPos = {
                            x: thisFlagArray.x * tileWidth,
                            y: thisFlagArray.y * tileWidth
                        }

                        ctx.fillStyle = 'pink';
                        ctx.fillRect(convertedPos.x, convertedPos.y, tileWidth, tileWidth);

                        (function (ctx, convertedPos) {
                            var flagImage = new Image();
                            flagImage.src = numberToImage['flag'];

                            flagImage.onload = function () {
                                ctx.drawImage(flagImage, convertedPos.x, convertedPos.y, tileWidth, tileWidth);
                            }
                        })(ctx, convertedPos);
                    }
                }

                bombLocations = data.saveBombLocations;
                foundLocations = data.saveFoundLocations;
                flagLocations = data.saveFlagLocations;
                gameStats = data.saveGameStats;
                numberDatabase = data.saveNumberDatabase;
                updateStats();
            }

            function windowClosed() {
                saveData();
            }

            function startAutosave() {
                saveData();

                autosave_text.classList.add('show');
                setTimeout(function () {
                    autosave_text.classList.remove('show');
                }, 1000);

                setTimeout(startAutosave, 30000);
            }

            function handleExport() {
                var exportResponse = confirm('Export your current game data?');

                if (exportResponse == true) {
                    var dataText = saveData();
                    var blob = new Blob([dataText], { type: 'text/plain' });

                    var a = document.createElement('a');
                    a.download = 'infinisweeper_export.txt';
                    a.href = window.URL.createObjectURL(blob);
                    a.style.display = 'none';

                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }

            function handleImport() {
                var importResponse = confirm('Import data from file? This will overwrite your current data.');

                if (importResponse == true) {
                    var input = document.createElement('input');
                    input.type = 'file';
                    input.style.display = 'none';

                    document.body.appendChild(input);

                    input.addEventListener('change', function (event) {
                        var file = event.target.files[0];
                        var reader = new FileReader();

                        reader.onload = function (event) {
                            var text = event.target.result;
                            var textUnpacked = Tableify(text);

                            if (text) {
                                handleGameReset(null, true);
                                loadData(textUnpacked);
                                //document.removeChild(input);
                            }
                        }

                        reader.readAsText(file);
                    });

                    input.click();
                }
            }

            function start() {
                var storage = localStorage.getItem('saveData');
                if (!storage) {
                    generateCanvas({ x: 0, y: 0 });
                    createStartingStreak();
                } else {
                    loadData();
                }
                startAutosave();
                handleMoveRender();
                document.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mouseup', handleMouseUp);
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                document.addEventListener('contextmenu', handleContextMenu);
                document.addEventListener('mousemove', handleMouseDrag);
                window.addEventListener('beforeunload', windowClosed);
                flag_button.addEventListener('mouseup', handleFlagMode);
                move_button.addEventListener('mouseup', handleMoveMode);
                center_button.addEventListener('mouseup', shiftToPosition);
                import_button.addEventListener('mouseup', handleImport);
                export_button.addEventListener('mouseup', handleExport);
                reset_button.addEventListener('mouseup', handleGameReset);
                chunk_bounds_check.addEventListener('change', handleChunkBounds);
                invert_colors_check.addEventListener('change', handleInvertColors);
            }
            start();
        </script>
    </body>
</body>